{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"pltf","text":"<p>The next generation of Infrastructure-as-Code: work with high-level constructs instead of getting lost in low-level cloud configuration.</p> <p>pltf is a higher-level Infrastructure-as-Code framework. Instead of hand-crafting low-level cloud config, you describe environments and services in concise YAML. pltf turns those high-level constructs into Terraform so you keep full portability\u2014generate the code, extend it, or take it with you.</p> <p> </p>"},{"location":"#why-pltf","title":"Why pltf","text":"<p>Infrastructure-as-code is essential, but working directly with low-level cloud and Terraform can be complex. pltf bakes in cloud/IaC best practices so you can set up automated, scalable, and secure infrastructure quickly\u2014without being a full-time DevOps engineer. Because pltf emits Terraform, you avoid lock-in and can extend or own the generated code at any time.</p>"},{"location":"#how-it-works","title":"How It Works","text":"<p>With pltf you write configuration files and run the CLI (locally or in CI/CD). The CLI connects to your cloud, renders Terraform (providers/backends/locals/remote state), and can execute Terraform for you.</p> <p>Status: active development, not yet production-hardened. Pin versions and review generated code before applying.</p> <p>There are two primary spec types:</p> <ul> <li>Environment: defines cloud/provider, account, region, backend, and shared modules (clusters, networks, IAM, ingress, etc.). You might have one per staging/prod/QA, or per engineer/PR for isolated sandboxes.</li> <li>Service: defines an application workload and the non-Kubernetes resources it needs, linked to an Environment. Service specs seamlessly connect to environment outputs and modules.</li> </ul> <p>Environment and service specs are linked via <code>metadata.ref</code> and <code>envRef</code>.</p>"},{"location":"#what-you-can-do","title":"What You Can Do","text":"<ul> <li>Generate IaC fast: turn Environment/Service YAML into Terraform with consistent providers/backends/remote state.</li> <li>Mix modules: use the embedded catalog or your own (<code>source: custom</code>) with the same wiring rules.</li> <li>Choose backends: store state in <code>s3|gcs|azurerm</code> regardless of target cloud; use profiles for cross-account S3.</li> <li>Run Terraform safely: <code>pltf terraform plan/apply/destroy/output/unlock</code> auto-generate before executing TF.</li> <li>Validate &amp; lint: structural checks plus suggestions (labels, unused vars).</li> <li>Preview: see provider/backend/labels/modules without running TF.</li> </ul>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Follow Getting Started.</li> <li>Explore repo examples (<code>example/env.yaml</code>, <code>example/service.yaml</code>).</li> <li>Review Security.</li> </ul>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>Installation</li> <li>Getting Started</li> <li>Platform Usage</li> <li>CLI Reference</li> <li>Spec Guide</li> <li>Modules &amp; Wiring</li> <li>Features</li> <li>References</li> <li>Security</li> </ul>"},{"location":"faq/","title":"FAQ","text":"<p>Placeholder content. Replace with real Q&amp;A.</p> <ul> <li>What is pltf? A CLI that turns YAML specs into Terraform.</li> <li>Can I use custom modules? Yes, set <code>source: custom</code> and provide a custom modules root.</li> <li>How do I pick a backend? Set <code>backend.type</code> to <code>s3|gcs|azurerm</code> regardless of provider.</li> </ul>"},{"location":"features/","title":"Features Overview","text":"<p>Each major capability has its own page:</p> <ul> <li>Profiles &amp; Defaults</li> <li>Validation &amp; Lint</li> <li>Backends</li> <li>Custom Modules</li> <li>Placeholders &amp; Wiring</li> <li>Secrets</li> <li>Variables</li> <li>Telemetry</li> </ul>"},{"location":"features/#secrets","title":"Secrets","text":"<ul> <li>What: Manage app secrets without embedding them in specs/code. Secrets are stored as Kubernetes secrets and injected as env vars.</li> <li>Why: Avoid leaking credentials; keep rotation simple.</li> <li>Usage: Define secret keys in your spec under <code>secrets</code> and supply values via environment variables or CLI <code>--var</code>. Secrets are treated as TF variables, not locals.</li> <li>Notes: Services restart to pick up changes unless <code>--no-restart</code> is used. Bulk updates can consume <code>.env</code>-style inputs; values should come from env/CI secret stores, not hardcoded files.</li> </ul>"},{"location":"features/#terraform-generator","title":"Terraform Generator","text":"<ul> <li>What: Render Terraform from env/service specs without applying; handy for review, migration, or running TF directly.</li> <li>Why: Keep portability\u2014inspect/modify TF, hand to CI, or migrate away without lock-in.</li> <li>Commands: <code>pltf generate</code> for TF only; <code>pltf terraform plan|apply|destroy|output|force-unlock</code> to generate + run.</li> <li>Example (env): <code>bash   pltf generate -f env.yaml -e prod -o .pltf/env/prod   # outputs providers.tf, backend.tf, modules/&lt;...&gt;, outputs.tf, versions.tf</code></li> <li>Example (service): <code>bash   pltf generate -f service.yaml -e prod -o .pltf/service/payments/prod</code></li> <li>Notes: Does not require cloud credentials to render. Backends are written per spec (<code>s3|gcs|azurerm</code>). Generated modules directory is self-contained for review or VCS.</li> </ul>"},{"location":"features/#variables","title":"Variables","text":"<ul> <li>What: Minimal templating to reuse specs across envs/services.</li> <li>Types: CLI <code>--var</code>, env-level <code>variables</code>, and placeholders.</li> <li>Placeholders: <code>${env_name}</code>, <code>${layer_name}</code>, <code>${module.&lt;id&gt;.&lt;output&gt;}</code>, <code>${parent.&lt;output&gt;}</code>, <code>${var.&lt;name&gt;}</code>.</li> <li>Spec inputs: Declare <code>variables</code> in env specs or use <code>--var key=value</code> at runtime; service specs inherit envRef variables and can override via CLI.</li> <li>Example (env):   ```yaml   variables:     min_nodes: \"2\"     max_nodes: \"5\"   modules:<ul> <li>type: aws_eks   min_nodes: \"${var.min_nodes}\"   max_nodes: \"${var.max_nodes}\"   <code></code>bash   pltf terraform apply -f env.yaml -e prod --var min_nodes=3 --var max_nodes=6   ```</li> </ul> </li> <li>Parent outputs: In services, <code>${parent.&lt;output&gt;}</code> references environment outputs (e.g., <code>${parent.domain}</code>).</li> </ul>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#homebrew-macoslinux","title":"Homebrew (macOS/Linux)","text":"<pre><code>brew tap yindia/pltf\nbrew install pltf\n</code></pre> <p>If you previously tapped another repo, run <code>brew untap &lt;old&gt;</code> before tapping <code>yindia/pltf</code>.</p>"},{"location":"installation/#install-script-macoslinuxwindows-via-wsl-or-git-bash","title":"Install script (macOS/Linux/Windows via WSL or Git Bash)","text":"<pre><code>curl -sSL https://raw.githubusercontent.com/yindia/pltf/main/scripts/install.sh | sh\n</code></pre> <p>Environment overrides: - <code>REPO_OWNER</code> / <code>REPO_NAME</code> to point at a fork - <code>VERSION</code> to pin a release tag (e.g. <code>v1.2.3</code>) - <code>DEST</code> to change install path (defaults to <code>/usr/local/bin</code>)</p>"},{"location":"installation/#docker","title":"Docker","text":"<pre><code>docker build -t pltf .\ndocker run --rm pltf --help\n</code></pre>"},{"location":"installation/#from-source","title":"From source","text":"<pre><code>go install ./...\n# or to build a local binary\ngo build -o bin/pltf main.go\n</code></pre>"},{"location":"installation/#verify","title":"Verify","text":"<pre><code>pltf --help\npltf validate -f env.yaml\n</code></pre>"},{"location":"installation/#upgrade","title":"Upgrade","text":"<ul> <li>Homebrew: <code>brew upgrade pltf</code></li> <li>Script: rerun the install script with the desired <code>VERSION</code></li> <li>From source: <code>git pull</code> then rebuild</li> </ul>"},{"location":"modules/","title":"Modules &amp; Wiring","text":"<p>Modules are discovered from a modules root where each module type directory contains a <code>module.yaml</code>. The CLI scans custom roots (when provided) and the embedded catalog. Modules marked <code>source: custom</code> must be found in your custom root; others fall back to embedded.</p>"},{"location":"modules/#wiring-rules","title":"Wiring rules","text":"<ul> <li>Inputs auto-wire to outputs with the same name (current scope, or parent env for services).</li> <li>Required inputs without a value or matching output fail validation.</li> <li>Optional/default inputs can stay unwired if nothing matches.</li> <li>Templates <code>${module.*}</code>, <code>${var.*}</code>, <code>${parent.*}</code> are supported and converted to Terraform traversals.</li> </ul>"},{"location":"modules/#module-metadata-moduleyaml","title":"Module metadata (module.yaml)","text":"<p>Example fields:</p> <pre><code>name: aws_eks\ntype: aws_eks\nprovider: aws\nversion: 1.0.0\ndescription: EKS cluster\ninputs:\n  - name: cluster_name\n    type: string\n    required: true\n  - name: enable_metrics\n    type: bool\n    required: true\n  - name: env_name\n    type: string\n    required: true\noutputs:\n  - name: k8s_cluster_name\n    type: string\n</code></pre> <p>Notes: - Inputs may include <code>description</code>, <code>default</code>, <code>capability</code> (optional). - Outputs may include <code>description</code>, <code>capability</code>. - Capabilities can declare <code>provides</code>/<code>accepts</code> to describe contracts.</p>"},{"location":"modules/#embedded-modules-aws","title":"Embedded modules (AWS)","text":"<ul> <li><code>aws_base</code>, <code>aws_dns</code>, <code>aws_eks</code>, <code>aws_k8s_base</code>, <code>aws_k8s_service</code>, <code>aws_nodegroup</code></li> <li><code>aws_postgres</code>, <code>aws_mysql</code>, <code>aws_redis</code>, <code>aws_dynamodb</code>, <code>aws_s3</code>, <code>aws_ses</code>, <code>aws_sns</code>, <code>aws_sqs</code>, <code>aws_documentdb</code></li> <li><code>aws_iam_role</code>, <code>aws_iam_policy</code>, <code>aws_iam_user</code></li> <li><code>cloudfront_distribution</code></li> </ul> <p>GCP/Azure: no bundled modules yet; use custom modules or your own registry. You can target GCP/Azure providers with custom modules and backends.</p>"},{"location":"modules/#custom-modules","title":"Custom modules","text":"<ul> <li>Mark spec entries with <code>source: custom</code> to force lookup in your custom modules root (<code>--modules</code> or profile <code>modules_root</code>).</li> <li>Generate <code>module.yaml</code> for your module with <code>pltf module init --path &lt;module_dir&gt; [--force]</code>.</li> <li>Inventory commands: <code>pltf module list|get [-m ./modules] -o table|json|yaml</code>.</li> </ul> <p>Treat modules as black boxes: configure via <code>inputs</code>, consume declared <code>outputs</code>, and let wiring handle references.</p>"},{"location":"modules/#module-init-helper","title":"Module init helper","text":"<p>Use <code>pltf module init --path &lt;module_dir&gt; [--force]</code> to generate or refresh <code>module.yaml</code> from an existing Terraform module. This inspects variables/outputs and writes a fresh descriptor (backing up or overwriting if <code>--force</code>).</p>"},{"location":"platform/","title":"Platform Usage","text":"<p>Use this page as a practical guide to the most common flows in pltf.</p>"},{"location":"platform/#validate-lint","title":"Validate + Lint","text":"<pre><code>pltf validate -f env.yaml -e prod\npltf validate -f service.yaml -e dev\n</code></pre> <ul> <li>Runs structural validation and lint suggestions (labels, unused vars).</li> <li>Picks environment from <code>--env</code>, <code>PLTF_DEFAULT_ENV</code>, or profile <code>default_env</code>.</li> </ul>"},{"location":"platform/#preview","title":"Preview","text":"<pre><code>pltf preview -f env.yaml -e prod\n</code></pre> <ul> <li>Shows provider, backend type, labels, and modules without running Terraform.</li> </ul>"},{"location":"platform/#generate-terraform-only","title":"Generate (Terraform only)","text":"<pre><code>pltf generate -f env.yaml -e dev\npltf generate -f service.yaml -e prod -m ./modules --out .pltf/service/prod\npltf generate -f service.yaml -e dev --var cluster_name=my-dev\n</code></pre> <ul> <li><code>--modules/-m</code> custom root; modules with <code>source: custom</code> resolve here first.</li> <li><code>--out/-o</code> defaults to <code>.pltf/&lt;env_name&gt;/env/&lt;env&gt;</code> or <code>.pltf/&lt;env_name&gt;/&lt;service&gt;/&lt;env&gt;</code>.</li> <li><code>--var/-v</code> merges over env vars \u2192 service envRef vars \u2192 CLI vars.</li> <li>File inputs pointing to existing files in the spec directory are copied into the output and paths are updated.</li> </ul>"},{"location":"platform/#terraform-commands","title":"Terraform commands","text":"<pre><code>pltf terraform plan    -f service.yaml -e dev    # supports --target, --parallelism, --detailed-exitcode, --plan-file\npltf terraform apply   -f env.yaml    -e prod\npltf terraform destroy -f env.yaml    -e prod\npltf terraform output  -f service.yaml -e dev --json\npltf terraform force-unlock -f env.yaml -e prod --lock-id=&lt;id&gt;\n</code></pre> <ul> <li>Automatically generates Terraform, ensures backend (S3/GCS/Azurerm).</li> <li>Common flags: <code>--target/-t</code>, <code>--parallelism/-p</code>, <code>--lock/-l</code>, <code>--lock-timeout/-T</code>, <code>--no-color/-C</code>, <code>--input/-i</code>, <code>--refresh/-r</code>, <code>--plan-file/-P</code>, <code>--detailed-exitcode/-d</code>, <code>--json/-j</code>.</li> </ul>"},{"location":"platform/#module-inventory","title":"Module inventory","text":"<pre><code>pltf module list [-m ./modules] [-o table|json|yaml]\npltf module get aws_eks [-m ./modules] [-o table|json|yaml]\npltf module init --path ./modules/aws_eks [--force]\n</code></pre> <ul> <li>Use <code>source: custom</code> in specs to force lookup from your custom root (<code>--modules</code> or profile <code>modules_root</code>); embedded modules remain available.</li> </ul>"},{"location":"platform/#profiles-defaults","title":"Profiles &amp; Defaults","text":"<ul> <li><code>~/.pltf/profile.yaml</code> (or <code>PLTF_PROFILE</code>) can set <code>modules_root</code>, <code>default_env</code>, <code>default_out</code>, <code>telemetry</code>.</li> <li><code>PLTF_DEFAULT_ENV</code> is also respected for picking the environment.</li> </ul>"},{"location":"platform/#backends","title":"Backends","text":"<ul> <li><code>backend.type</code> can be <code>s3|gcs|azurerm</code> (independent of provider).</li> <li><code>backend.profile</code> supports cross-account S3; optional <code>region</code>, <code>container</code>, <code>resource_group</code>.</li> </ul>"},{"location":"specs/","title":"Spec Guide","text":"<p>pltf reads YAML specs with <code>kind: Environment</code> or <code>kind: Service</code>. The CLI validates structure and wires modules based on names and templated references.</p>"},{"location":"specs/#environment-spec-kind-environment","title":"Environment spec (kind: Environment)","text":"<p>Minimal shape:</p> <pre><code>apiVersion: platform.io/v1\nkind: Environment\nmetadata:\n  name: example-aws\n  org: example-org\n  provider: aws\n  labels:\n    team: platform\nbackend:\n  type: s3\n  bucket: example-tfstate   # optional; auto-named if omitted\n  region: us-east-1\nenvironments:\n  dev:\n    account: \"111111111111\"\n    region: us-east-1\n    variables:\n      base_domain: dev.example.com\n    secrets:\n      db_password: {}\nmodules:\n  - id: base\n    type: aws_base\n  - id: dns\n    type: aws_dns\n    inputs:\n      domain: var.base_domain\n</code></pre> <p>Notes: - <code>environments</code> map holds per-env accounts/regions/vars/secrets. - <code>modules</code> list holds shared modules; <code>id</code>/<code>type</code> required; <code>inputs</code> optional; <code>links</code> supported. - Backend: <code>backend.type</code> can be <code>s3|gcs|azurerm</code> (independent of provider). <code>backend.profile</code> supports cross-account S3; <code>container/resource_group</code> for azurerm. - Modules can set <code>source: custom</code> to force resolution from your custom modules root (<code>--modules</code> or profile <code>modules_root</code>); others fall back to the embedded catalog.</p>"},{"location":"specs/#service-spec-kind-service","title":"Service spec (kind: Service)","text":"<p>Minimal shape:</p> <pre><code>apiVersion: platform.io/v1\nkind: Service\nmetadata:\n  name: payments-api\n  ref: ./env.yaml       # path to Environment spec\n  envRef:\n    dev:\n      variables:\n        cluster_name: dev-cluster\nmodules:\n  - id: app\n    type: aws_k8s_service\n    inputs:\n      cluster_name: var.cluster_name\n      public_uri: \"/payments\"\n      image: \"ghcr.io/acme/payments:latest\"\n    links:\n      readwrite:\n        - db\n  - id: db\n    type: aws_postgres\n</code></pre> <p>Notes: - <code>metadata.ref</code> points to the Environment file (relative paths allowed). - <code>envRef</code> holds per-env variables/secrets merged after environment variables. - Modules can reference environment outputs via <code>${parent.&lt;output&gt;}</code>.</p>"},{"location":"specs/#variable-precedence","title":"Variable precedence","text":"<p>1) Environment variables 2) Service envRef variables (service only) 3) CLI <code>--var key=value</code></p>"},{"location":"specs/#secrets-vs-locals","title":"Secrets vs locals","text":"<ul> <li>Secrets remain as Terraform variables (<code>var.&lt;name&gt;</code>).</li> <li>Non-secrets become locals; <code>var.&lt;name&gt;</code> resolves to locals unless marked secret.</li> </ul>"},{"location":"specs/#templated-references","title":"Templated references","text":"<ul> <li><code>${module.&lt;module&gt;.&lt;output&gt;}</code> \u2014 module output in current scope</li> <li><code>${var.&lt;name&gt;}</code> \u2014 logical variable; wires to locals/secrets when names match</li> <li><code>${parent.&lt;output&gt;}</code> \u2014 environment output via remote state (service only)</li> <li><code>${env_name}</code> / <code>${layer_name}</code> \u2014 intrinsic placeholders; for services, <code>layer_name</code> is the service name</li> </ul>"},{"location":"usage/","title":"CLI Usage","text":"<p>pltf auto-detects whether a spec is an Environment or Service based on <code>kind</code>. Most commands accept <code>--file/-f</code>, <code>--env/-e</code>, <code>--modules/-m</code>, <code>--out/-o</code>, and <code>--var/-v key=value</code>. Profiles (<code>~/.pltf/profile.yaml</code> or <code>PLTF_PROFILE</code>) can set defaults for <code>modules_root</code> and <code>default_env</code>.</p>"},{"location":"usage/#command-catalog","title":"Command catalog","text":"<ul> <li><code>pltf validate</code> \u2014 validate + lint specs.</li> <li><code>pltf generate</code> \u2014 render Terraform only.</li> <li><code>pltf preview</code> \u2014 summarize provider/backend/labels/modules.</li> <li><code>pltf terraform plan|apply|destroy|output|force-unlock|graph</code> \u2014 generate + run Terraform with standard TF flags.</li> <li><code>pltf module list|get|init</code> \u2014 module inventory and metadata generation.</li> <li><code>pltf lint</code> \u2014 lint only (also run implicitly by validate).</li> </ul>"},{"location":"usage/#validate","title":"validate","text":"<ul> <li>What: Validate Environment or Service specs; auto-detects kind; runs lint suggestions (labels, unused vars).</li> <li>Flags:</li> <li><code>--file/-f</code> \u2014 Path to the spec (default <code>env.yaml</code>).</li> <li><code>--env/-e</code> \u2014 Environment key (dev/prod/etc.).</li> <li>Example: <code>pltf validate -f service.yaml -e dev</code></li> </ul>"},{"location":"usage/#generate","title":"generate","text":"<ul> <li>What: Render Terraform only; no init/apply.</li> <li>Flags:</li> <li><code>--file/-f</code> \u2014 Path to the spec.</li> <li><code>--env/-e</code> \u2014 Environment key.</li> <li><code>--modules/-m</code> \u2014 Custom modules root; <code>source: custom</code> resolves here first.</li> <li><code>--out/-o</code> \u2014 Output dir (defaults to <code>.pltf/&lt;env_name&gt;/env/&lt;env&gt;</code> or <code>.pltf/&lt;env_name&gt;/&lt;service&gt;/&lt;env&gt;</code>).</li> <li><code>--var/-v</code> \u2014 CLI var override <code>key=value</code>.</li> <li>Example: <code>pltf generate -f service.yaml -e prod -m ./modules --out .pltf/service/prod</code></li> </ul>"},{"location":"usage/#preview","title":"preview","text":"<ul> <li>What: Show provider, backend, labels, modules without running Terraform.</li> <li>Flags: <code>--file/-f</code>, <code>--env/-e</code></li> <li>Example: <code>pltf preview -f env.yaml -e prod</code></li> </ul>"},{"location":"usage/#terraform-plan","title":"terraform plan","text":"<ul> <li>What: Generate + run <code>terraform plan</code> with standard flags.</li> <li>Plan flags:</li> <li><code>--target/-t</code> \u2014 Target address (repeatable).</li> <li><code>--parallelism/-p</code> \u2014 Max parallel operations.</li> <li><code>--lock/-l</code> \u2014 Lock state (default true).</li> <li><code>--lock-timeout/-T</code> \u2014 Lock timeout (e.g., 30s).</li> <li><code>--no-color/-C</code> \u2014 Disable color output.</li> <li><code>--input/-i</code> \u2014 Prompt for input (default false).</li> <li><code>--refresh/-r</code> \u2014 Refresh state before plan (default true).</li> <li><code>--detailed-exitcode/-d</code> \u2014 Enable TF detailed exit codes.</li> <li><code>--plan-file/-P</code> \u2014 Write plan to a file.</li> <li>Shared flags: <code>--file/-f</code>, <code>--env/-e</code>, <code>--modules/-m</code>, <code>--out/-o</code>, <code>--var/-v</code></li> <li>Example: <code>pltf terraform plan -f service.yaml -e dev --detailed-exitcode --plan-file=/tmp/plan.tfplan</code></li> </ul>"},{"location":"usage/#terraform-apply","title":"terraform apply","text":"<ul> <li>What: Generate + run <code>terraform apply -auto-approve</code>.</li> <li>Flags: Shared flags (<code>--file/-f</code>, <code>--env/-e</code>, <code>--modules/-m</code>, <code>--out/-o</code>, <code>--var/-v</code>).</li> <li>Example: <code>pltf terraform apply -f env.yaml -e prod</code></li> </ul>"},{"location":"usage/#terraform-destroy","title":"terraform destroy","text":"<ul> <li>What: Generate (if needed) + run <code>terraform destroy -auto-approve</code>.</li> <li>Flags: Same as apply.</li> <li>Example: <code>pltf terraform destroy -f env.yaml -e prod</code></li> </ul>"},{"location":"usage/#terraform-output","title":"terraform output","text":"<ul> <li>What: Show outputs (optionally JSON).</li> <li>Flags: <code>--json/-j</code> (JSON output), plus shared <code>--file/-f</code>, <code>--env/-e</code>, <code>--modules/-m</code>, <code>--out/-o</code></li> <li>Example: <code>pltf terraform output -f service.yaml -e dev --json</code></li> </ul>"},{"location":"usage/#terraform-force-unlock","title":"terraform force-unlock","text":"<ul> <li>What: Force unlock state.</li> <li>Flags: <code>--lock-id</code> (required), plus shared <code>--file/-f</code>, <code>--env/-e</code>, <code>--modules/-m</code>, <code>--out/-o</code></li> <li>Example: <code>pltf terraform force-unlock -f env.yaml -e prod --lock-id=12345</code></li> </ul>"},{"location":"usage/#terraform-graph","title":"terraform graph","text":"<ul> <li>What: Emit DOT graph. Default runs <code>terraform graph</code>; <code>--mode spec</code> renders a dependency graph from the YAML only.</li> <li>Flags: <code>--mode terraform|spec</code> (default terraform), <code>--plan-file/-P</code> (passed to terraform graph), plus shared <code>--file/-f</code>, <code>--env/-e</code>, <code>--modules/-m</code>, <code>--out/-o</code></li> <li>Example: <code>pltf terraform graph -f env.yaml -e dev | dot -Tpng &gt; graph.png</code></li> </ul>"},{"location":"usage/#module-list","title":"module list","text":"<ul> <li>What: List module inventory from embedded/custom roots.</li> <li>Flags: <code>--modules/-m</code> (modules root), <code>--output/-o</code> (<code>table|json|yaml</code>)</li> <li>Example: <code>pltf module list -m ./modules -o json</code></li> </ul>"},{"location":"usage/#module-get","title":"module get","text":"<ul> <li>What: Show module details (inputs/outputs).</li> <li>Flags: Same as module list.</li> <li>Example: <code>pltf module get aws_eks -m ./modules</code></li> </ul>"},{"location":"usage/#module-init","title":"module init","text":"<ul> <li>What: Generate <code>module.yaml</code> from an existing Terraform module dir.</li> <li>Flags: <code>--path</code> (module dir), <code>--name</code>, <code>--type</code>, <code>--description</code>, <code>--out</code>, <code>--force</code> (overwrite)</li> <li>Example: <code>pltf module init --path ./modules/aws_eks --force</code></li> </ul>"},{"location":"usage/#validate-lint","title":"Validate + Lint","text":"<p>Structural validation plus lint suggestions (labels, unused vars).</p> <pre><code>pltf validate -f env.yaml -e prod\npltf validate -f service.yaml -e dev\n</code></pre>"},{"location":"usage/#generate_1","title":"Generate","text":"<p>Render Terraform without running it. File inputs that point to existing files (relative to the spec) are copied into the output directory and paths are updated.</p> <pre><code>pltf generate -f env.yaml -e dev\npltf generate -f service.yaml -e prod -o .pltf/service/prod\npltf generate -f service.yaml -e dev -m ./custom-mods --var cluster_name=my-dev\n</code></pre> <p>Flags: - <code>--modules/-m</code> custom modules root. Modules with <code>source: custom</code> are resolved only from the custom root; others fall back to embedded modules. - <code>--out/-o</code> output dir (defaults <code>.pltf/&lt;env_name&gt;/env/&lt;env&gt;</code> or <code>.pltf/&lt;env_name&gt;/&lt;service&gt;/&lt;env&gt;</code>). - <code>--var/-v</code> merges vars (env vars \u2192 service envRef vars \u2192 CLI vars).</p>"},{"location":"usage/#terraform-helpers","title":"Terraform helpers","text":"<p>Terraform commands live under <code>pltf terraform ...</code> and auto-generate before running TF.</p> <pre><code>pltf terraform plan    -f service.yaml -e dev    # plan (supports --target, --parallelism, --detailed-exitcode, --plan-file)\npltf terraform apply   -f env.yaml    -e prod    # apply\npltf terraform destroy -f env.yaml    -e prod    # destroy\npltf terraform output  -f service.yaml -e dev    # outputs (--json supported)\npltf terraform force-unlock -f env.yaml -e prod --lock-id=&lt;id&gt;\n</code></pre> <p>Common flags: <code>--target/-t</code>, <code>--parallelism/-p</code>, <code>--lock/-l</code>, <code>--lock-timeout/-T</code>, <code>--no-color/-C</code>, <code>--input/-i</code>, <code>--refresh/-r</code>, <code>--plan-file/-P</code>, <code>--detailed-exitcode/-d</code>, <code>--json/-j</code>.</p>"},{"location":"usage/#preview_1","title":"Preview","text":"<p>Quick summary (provider, backend, labels, modules) without TF.</p> <pre><code>pltf preview -f env.yaml -e prod\n</code></pre>"},{"location":"usage/#module-inventory","title":"Module inventory","text":"<pre><code>pltf module list [-m ./modules] [-o table|json|yaml]\npltf module get aws_eks [-m ./modules] [-o table|json|yaml]\npltf module init --path ./modules/aws_eks [--force]\n</code></pre>"},{"location":"usage/#custom-backends","title":"Custom backends","text":"<p>In env spec <code>backend.type</code> can be <code>s3|gcs|azurerm</code> regardless of provider. Optional <code>region</code>, <code>container</code>, <code>resource_group</code>, <code>profile</code> (S3) supported.</p>"},{"location":"usage/#custom-modules","title":"Custom modules","text":"<ul> <li>Mark a module with <code>source: custom</code> to force lookup in your custom modules root.</li> <li>Provide a custom root via <code>--modules</code> or profile <code>modules_root</code>; embedded modules remain available for everything else.</li> <li>Generate module.yaml for your own TF module with <code>pltf module init --path &lt;module_dir&gt; [--force]</code>.</li> </ul>"},{"location":"usage/#environment-defaults","title":"Environment defaults","text":"<p><code>PLTF_DEFAULT_ENV</code> or profile <code>default_env</code> let you omit <code>--env</code> when only one environment applies.</p>"},{"location":"usage/#completions","title":"Completions","text":"<pre><code>pltf completion bash|zsh|fish|powershell\n</code></pre>"},{"location":"concepts/environment/","title":"Environment","text":"<p>The common frame that powers your infrastructure.</p>"},{"location":"concepts/environment/#what-is-an-environment","title":"What is an Environment?","text":"<p>Environment specs declare which cloud/account/region to configure. From this file, pltf can create the base resources (e.g., Kubernetes clusters, networks, IAM roles, ingress). You\u2019ll usually have one per staging/prod/QA; you can also create per-engineer or per-PR environments for isolated sandboxes.</p> <p> </p>"},{"location":"concepts/environment/#definition-yaml","title":"Definition (YAML)","text":"<pre><code>apiVersion: platform.io/v1\nkind: Environment\nmetadata:\n  name: example-aws\n  org: myorg\n  provider: aws        # cloud provider\n  labels:\n    team: platform\nbackend:\n  type: s3             # s3|gcs|azurerm\n  bucket: my-tf-bucket # optional; auto-named if omitted\n  region: us-east-1\nenvironments:\n  prod:\n    account: \"123456789012\"\n    region: us-east-1\n    variables:\n      base_domain: prod.example.com\nmodules:\n  - id: base\n    type: aws_base\n  - id: eks\n    type: aws_eks\n    inputs:\n      cluster_name: var.base_domain\n</code></pre> <p>Key points: - <code>metadata</code> sets name/org/provider and optional labels (become global tags). - <code>backend.type</code> can be <code>s3|gcs|azurerm</code> (independent of provider). <code>backend.profile</code> supports cross-account S3. - <code>environments</code> map holds per-env account/region/vars/secrets; pick one via <code>--env</code> or profile <code>default_env</code>. - <code>modules</code> are shared across services; use embedded catalog or <code>source: custom</code> to pull from your own root.</p>"},{"location":"concepts/environment/#state-storage","title":"State Storage","text":"<p>pltf uses your cloud\u2019s native bucket for remote state (S3/GCS/Azurerm). One bucket per environment; state and metadata for the environment and its services live as separate objects. Backends are managed via <code>backend.*</code> and can be cross-cloud (e.g., Azure env with S3 backend).</p>"},{"location":"concepts/environment/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Modules.</li> <li>Explore Service (coming soon) to connect workloads to environments.</li> </ul>"},{"location":"concepts/layer/","title":"Layer (Service)","text":"<p>An independently managed set of modules.</p>"},{"location":"concepts/layer/#what-is-a-layer","title":"What is a Layer?","text":"<p>You can put all modules in an Environment file, but for finer granularity you define layers (Services). A layer provisions a set of modules together as a single unit and links to an Environment.</p> <p>Layers have: - a unique name - the environment(s) they run in (via <code>metadata.ref</code> / <code>envRef</code>) - a list of modules (with optional links and inputs)</p> <p> </p>"},{"location":"concepts/layer/#when-to-use-layers","title":"When to use layers?","text":"<ul> <li>Break down a large environment into separately maintained stacks.</li> <li>Share module definitions across multiple environments without duplicating YAML.</li> <li>Isolate per-service concerns (e.g., app plus its database) while reusing environment foundations.</li> </ul>"},{"location":"concepts/layer/#definition-yaml","title":"Definition (YAML)","text":"<p>Example: a service (layer) for a Kubernetes workload with a database.</p> <pre><code>apiVersion: platform.io/v1\nkind: Service\nmetadata:\n  name: payments-api\n  ref: ../env.yaml           # link to Environment\n  envRef:\n    prod: {}                 # environment keys supported\nmodules:\n  - id: app\n    type: aws_k8s_service\n    inputs:\n      public_uri: \"/payments\"\n      image: \"ghcr.io/acme/payments:latest\"\n    links:\n      readwrite:\n        - db\n  - id: db\n    type: aws_postgres\n    inputs:\n      instance_class: db.t3.medium\n</code></pre> <p>Notes: - Service name maps to <code>${layer_name}</code> placeholder; <code>${env_name}</code> is the environment key. - Modules can link to each other (<code>links</code>) to consume outputs without manual wiring (e.g., <code>${module.db.db_host}</code>). - Per-environment overrides live under <code>metadata.envRef</code>.</p>"},{"location":"concepts/layer/#next-steps","title":"Next Steps","text":"<ul> <li>See Environment for foundations.</li> <li>Explore module details in References.</li> </ul>"},{"location":"concepts/module/","title":"Module","text":"<p>A high-level building block to provision infrastructure.</p>"},{"location":"concepts/module/#what-is-a-module","title":"What is a Module?","text":"<p>pltf includes an embedded library of modules you can connect to build your stack. Each module is a high-level construct that provisions the resources needed to achieve its goal (e.g., EKS cluster, S3 bucket, Postgres).</p> <p>Modules are described by <code>module.yaml</code> (type/provider/version/inputs/outputs) and referenced in your Environment or Service spec.</p> <p> </p>"},{"location":"concepts/module/#definition","title":"Definition","text":"<p>Modules have: - a type (e.g., <code>aws_eks</code>, <code>aws_s3</code>) - an optional id/name (so you can include multiple of the same type) - optional inputs (configuration) - optional links (to consume other module outputs) - optional source (<code>custom</code> forces lookup in your custom modules root)</p> <p>Modules are defined inside the <code>modules</code> section of an Environment or Service.</p>"},{"location":"concepts/module/#minimal-configuration","title":"Minimal configuration","text":"<p>We built pltf so you can provision a resource with a single line. Defaults follow best practices; customize only what you need.</p> <pre><code>modules:\n  - id: cluster\n    type: aws_eks\n  - id: db\n    type: aws_postgres\n</code></pre>"},{"location":"concepts/module/#extra-configuration","title":"Extra configuration","text":"<p>Override only the fields you care about; pltf uses recommended defaults otherwise.</p> <pre><code>modules:\n  - id: devcluster\n    type: aws_eks\n    inputs:\n      node_instance_type: t3.medium\n      max_nodes: 5\n      spot_instances: true\n  - id: dbfrontend\n    type: aws_postgres\n    inputs:\n      instance_class: db.t3.medium\n      engine_version: \"12.4\"\n</code></pre>"},{"location":"concepts/module/#links-module-outputs-as-inputs","title":"Links (module outputs as inputs)","text":"<p>Modules can consume outputs from others using <code>links</code> or direct references like <code>${module.redis.cache_host}</code>.</p> <pre><code>modules:\n  - id: redis\n    type: aws_redis\n  - id: airflow\n    type: helm_chart\n    inputs:\n      repository: https://airflow.apache.org\n      chart: airflow\n      namespace: airflow\n      chart_version: 1.4.0\n      values:\n        brokerUrl: \"rediss://:${module.redis.cache_auth_token}@${module.redis.cache_host}\"\n</code></pre>"},{"location":"concepts/module/#custom-modules","title":"Custom modules","text":"<p>Generate <code>module.yaml</code> for your own Terraform module via <code>pltf module init --path &lt;module_dir&gt; [--force]</code>. Use <code>source: custom</code> in specs and provide <code>--modules</code> (or profile <code>modules_root</code>) to load them.</p>"},{"location":"concepts/module/#terraform-compatible","title":"Terraform compatible","text":"<p>pltf uses Terraform under the hood, so you\u2019re never locked in. Extend with your own Terraform or take the generated code with you.</p>"},{"location":"concepts/module/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Layer/Service (coming soon).</li> <li>Explore the module API in References and per-module pages.</li> </ul>"},{"location":"concepts/overview/","title":"Concepts Overview","text":"<p>pltf is Infrastructure-as-Code with a higher-level abstraction. You write configuration files, then run the pltf CLI (locally or in CI/CD) to connect to your cloud account and provision resources using Terraform under the hood.</p> <p> </p>"},{"location":"concepts/overview/#how-it-works","title":"How It Works","text":"<p>1) Author YAML specs. 2) Run <code>pltf preview|validate|generate|terraform ...</code>. 3) The CLI renders Terraform (providers, backends, locals, remote state) and can execute Terraform for you.</p> <p>There are two primary spec types:</p> <ul> <li>Environment: Specifies cloud, account, and region. Running an Environment sets up the base resources (e.g., Kubernetes cluster, networks, IAM, ingress). Typical patterns: one per staging/prod/QA, or one per engineer/PR for isolated sandboxes.</li> <li>Service (Layer): Specifies the workload (often a microservice) and any non-Kubernetes resources it needs (e.g., databases, queues). pltf connects these seamlessly to the Environment.</li> </ul> <p>Environment and Service specs link via <code>metadata.ref</code> (path to env) and <code>envRef</code> (per-environment overrides).</p>"},{"location":"features/backends/","title":"Backends","text":"<p>Choose where Terraform state lives, independent of the target cloud.</p>"},{"location":"features/backends/#what-it-does","title":"What it does","text":"<ul> <li>Supports <code>backend.type</code> = <code>s3|gcs|azurerm</code> for any provider.</li> <li>Allows <code>backend.profile</code> for cross-account S3, <code>region</code> override, and container/resource_group for azurerm.</li> <li>Ensures the backend bucket/container exists before running Terraform.</li> </ul>"},{"location":"features/backends/#example","title":"Example","text":"<pre><code>backend:\n  type: s3\n  bucket: platform-tfstate\n  region: us-east-1\n  profile: ops-account\n</code></pre>"},{"location":"features/backends/#notes","title":"Notes","text":"<ul> <li>Backends are rendered into <code>backend.tf</code>/<code>terraform.tfvars</code> alongside providers.</li> <li>You can point all clouds to a single backend (e.g., S3) if desired.</li> </ul>"},{"location":"features/custom-modules/","title":"Custom Modules","text":"<p>Mix embedded modules with your own Terraform modules.</p>"},{"location":"features/custom-modules/#what-it-does","title":"What it does","text":"<ul> <li>Uses the embedded catalog by default.</li> <li>Supports a custom modules root (<code>--modules</code> or profile <code>modules_root</code>).</li> <li><code>source: custom</code> on a module forces lookup in your custom root; others fall back to embedded.</li> <li><code>pltf module init</code> inspects a TF module and writes <code>module.yaml</code> metadata.</li> <li>Inventory commands: <code>pltf module list|get -o table|json|yaml</code>.</li> </ul>"},{"location":"features/custom-modules/#example","title":"Example","text":"<pre><code>modules:\n  - name: app\n    type: my_custom_service\n    source: custom\n    image: ghcr.io/acme/app:latest\n</code></pre>"},{"location":"features/custom-modules/#notes","title":"Notes","text":"<ul> <li>Custom and embedded modules can coexist in the same spec.</li> <li>Module metadata (<code>module.yaml</code>) drives inputs/outputs and wiring; keep it committed.</li> </ul>"},{"location":"features/placeholders/","title":"Placeholders &amp; Wiring","text":"<p>Lightweight templating to keep specs DRY and wire modules together.</p>"},{"location":"features/placeholders/#what-it-does","title":"What it does","text":"<ul> <li>Intrinsics: <code>${env_name}</code>, <code>${layer_name}</code>.</li> <li>References: <code>${module.&lt;id&gt;.&lt;output&gt;}</code>, <code>${parent.&lt;output&gt;}</code> (services), <code>${var.&lt;name&gt;}</code>.</li> <li>Auto-wires inputs to outputs when names match within scope; missing required values fail validation.</li> </ul>"},{"location":"features/placeholders/#examples","title":"Examples","text":"<pre><code>public_uri: \"https://${module.dns.domain}\"\nbucket_name: \"app-${env_name}\"\nmax_nodes: \"${var.max_nodes}\"\npublic_url: \"${parent.domain}/hello\"   # in a service spec\n</code></pre>"},{"location":"features/placeholders/#notes","title":"Notes","text":"<ul> <li>Services can reference parent env outputs via <code>${parent.*}</code>.</li> <li>Variables precedence: env vars \u2192 service envRef vars \u2192 CLI <code>--var</code>.</li> </ul>"},{"location":"features/preview/","title":"Preview","text":"<p>Quickly inspect what will be generated without touching Terraform.</p>"},{"location":"features/preview/#what-it-does","title":"What it does","text":"<ul> <li><code>pltf preview</code> reads your spec and shows provider, backend type, labels, and modules that will render.</li> <li>Auto-detects env vs service based on <code>kind</code>.</li> </ul>"},{"location":"features/preview/#example","title":"Example","text":"<pre><code>pltf preview -f env.yaml -e prod\n</code></pre>"},{"location":"features/preview/#notes","title":"Notes","text":"<ul> <li>No cloud credentials needed; useful in CI or pre-commit checks.</li> <li>Pair with <code>pltf validate</code> for faster feedback before generation/apply.</li> </ul>"},{"location":"features/profiles/","title":"Profiles &amp; Defaults","text":"<p>Set org-wide defaults so users type fewer flags and stay consistent.</p>"},{"location":"features/profiles/#what-it-does","title":"What it does","text":"<ul> <li>Reads <code>~/.pltf/profile.yaml</code> (or <code>PLTF_PROFILE</code>) for defaults like <code>modules_root</code>, <code>default_env</code>, <code>default_out</code>, and <code>telemetry</code>.</li> <li>Lets you pick a custom modules root for all commands without repeating <code>--modules</code>.</li> <li>Allows a default environment name so <code>--env</code> can be omitted when unambiguous.</li> </ul>"},{"location":"features/profiles/#example-profile","title":"Example profile","text":"<pre><code>modules_root: /infra/modules\ndefault_env: dev\ndefault_out: .pltf\ntelemetry: false\n</code></pre>"},{"location":"features/profiles/#usage","title":"Usage","text":"<ul> <li>Any CLI flags you pass override profile settings.</li> <li>Profiles are optional; when absent, embedded modules and CLI flags are used.</li> </ul>"},{"location":"features/secrets/","title":"Secrets","text":"<p>Keep sensitive values out of specs and source control.</p>"},{"location":"features/secrets/#what-it-does","title":"What it does","text":"<ul> <li>Secrets stay as Terraform variables and render to Kubernetes secrets for services.</li> <li>You declare secret keys in your spec; actual values are provided at runtime via environment variables or <code>--var</code>, typically sourced from your secret store/CI.</li> <li>Services receive secrets as env vars; no values are written into locals or files.</li> </ul>"},{"location":"features/secrets/#example-service","title":"Example (service)","text":"<pre><code>spec:\n  secrets:\n    db_password: {}   # value supplied via env/CI\n  modules:\n    - type: aws_k8s_service\n      name: app\n      env_vars:\n        - name: DB_PASSWORD\n          value: \"${var.db_password}\"\n</code></pre> <p>Runtime:</p> <pre><code>PLTF_VAR_db_password=supersecret pltf terraform apply -f service.yaml -e prod\n</code></pre>"},{"location":"features/secrets/#notes","title":"Notes","text":"<ul> <li>Prefer env/CI secret stores; do not commit secret values to specs or repos.</li> <li>Services restart to pick up new secret values after apply; plan rotations accordingly.</li> </ul>"},{"location":"features/telemetry/","title":"Telemetry","text":"<p>Optional usage reporting.</p>"},{"location":"features/telemetry/#what-it-does","title":"What it does","text":"<ul> <li>Uses a global <code>--telemetry</code> flag (defaults from profile) to enable/disable future analytics.</li> <li>Currently a stub/no-op; reserved for opt-in reporting.</li> </ul>"},{"location":"features/telemetry/#usage","title":"Usage","text":"<ul> <li>Set in profile:   <code>yaml   telemetry: false</code></li> <li>Or export <code>PLTF_TELEMETRY=0</code> to disable.</li> </ul>"},{"location":"features/terraform-commands/","title":"Terraform Commands","text":"<p>Run Terraform with consistent, auto-generated configs.</p>"},{"location":"features/terraform-commands/#what-it-does","title":"What it does","text":"<ul> <li>Commands live under <code>pltf terraform plan|apply|destroy|output|force-unlock</code>.</li> <li>Auto-generates Terraform (providers, backends, modules, outputs) before running TF.</li> <li>Ensures the backend bucket/container exists (S3/GCS/Azurerm) before init/apply.</li> <li>Passes through standard TF flags (targets, parallelism, lock, no-color, plan file, detailed exit codes).</li> </ul>"},{"location":"features/terraform-commands/#examples","title":"Examples","text":"<pre><code>pltf terraform plan -f service.yaml -e dev --detailed-exitcode --plan-file=/tmp/plan.tfplan\npltf terraform apply -f env.yaml -e prod\npltf terraform destroy -f env.yaml -e prod\npltf terraform output -f service.yaml -e dev --json\npltf terraform force-unlock -f env.yaml -e prod --lock-id=12345\n</code></pre>"},{"location":"features/terraform-commands/#notes","title":"Notes","text":"<ul> <li>Backends are decoupled from provider (<code>s3|gcs|azurerm</code> supported).</li> <li>Common flags: <code>--target/-t</code>, <code>--parallelism/-p</code>, <code>--lock/-l</code>, <code>--lock-timeout/-T</code>, <code>--no-color/-C</code>, <code>--input/-i</code>, <code>--refresh/-r</code>, <code>--plan-file/-P</code>, <code>--detailed-exitcode/-d</code>, <code>--json/-j</code>.</li> <li>Uses the same generation path as <code>pltf generate</code>; you can inspect the rendered TF in the output directory.</li> </ul>"},{"location":"features/terraform-generator/","title":"Terraform Generator","text":"<p>Render Terraform from your specs without applying. Ideal for reviews, CI, or migrating to raw Terraform.</p>"},{"location":"features/terraform-generator/#overview","title":"Overview","text":"<p><code>pltf generate</code> reads Environment or Service specs, auto-detects kind, and writes a self-contained Terraform directory (providers, backend, modules, outputs, versions). No cloud credentials are required to render.</p>"},{"location":"features/terraform-generator/#generate-terraform","title":"Generate Terraform","text":"<p>Environment:</p> <pre><code>pltf generate -f env.yaml -e prod -o .pltf/env/prod\n# produces:\n# .pltf/env/prod/\n# \u251c\u2500 modules/               # copied/embedded module code used by this stack\n# \u251c\u2500 providers.tf           # provider blocks + required versions\n# \u251c\u2500 backend.tf             # state backend (s3|gcs|azurerm)\n# \u251c\u2500 locals.tf              # computed locals/labels\n# \u251c\u2500 modules-*.tf           # module instantiations\n# \u251c\u2500 outputs.tf             # outputs\n# \u2514\u2500 versions.tf            # provider/Terraform constraints\n</code></pre> <p>Service:</p> <pre><code>pltf generate -f service.yaml -e prod -o .pltf/service/payments/prod\n</code></pre>"},{"location":"features/terraform-generator/#migrate-to-terraform","title":"Migrate to Terraform","text":"<ul> <li>Run <code>pltf generate</code> (or <code>pltf terraform plan</code> to generate+init) for each env/service stack.</li> <li>Commit the generated directory to VCS if you want to manage TF directly.</li> <li>Backends follow your spec; use <code>backend.type</code> (<code>s3|gcs|azurerm</code>) to point at your state bucket/container.</li> </ul>"},{"location":"features/terraform-generator/#notes","title":"Notes","text":"<ul> <li>No provider calls during generation; safe to run without credentials.</li> <li>Supports custom modules (<code>source: custom</code>) alongside embedded ones; the generated <code>modules/</code> directory is self-contained.</li> <li>Use <code>pltf preview</code> first to sanity check provider/backend/modules before generation.</li> </ul>"},{"location":"features/validation/","title":"Validation &amp; Lint","text":"<p>Catch spec issues early before generation or apply.</p>"},{"location":"features/validation/#what-it-does","title":"What it does","text":"<ul> <li><code>pltf validate</code> runs structural validation for Environment and Service specs.</li> <li>Built-in lint suggests labels and flags unused variables.</li> <li>Auto-detects <code>kind</code> (env/service) and applies the right checks.</li> </ul>"},{"location":"features/validation/#example","title":"Example","text":"<pre><code>pltf validate -f env.yaml -e prod\npltf validate -f service.yaml -e dev\n</code></pre>"},{"location":"features/validation/#notes","title":"Notes","text":"<ul> <li>Lint also runs implicitly during validate.</li> <li>Combine with <code>pltf preview</code> to sanity check providers/backends/modules.</li> </ul>"},{"location":"features/variables/","title":"Variables","text":"<p>Reuse specs across environments and services with minimal templating.</p>"},{"location":"features/variables/#overview","title":"Overview","text":"<p>Variables can be declared in your specs and overridden at runtime. They resolve into Terraform variables so you can keep a single spec and tune it per environment.</p>"},{"location":"features/variables/#declare-variables","title":"Declare variables","text":"<p>Define inputs in your spec and reference them with <code>${var.&lt;name&gt;}</code>:</p> <pre><code>variables:\n  min_nodes: \"2\"\n  max_nodes: \"5\"\nmodules:\n  - type: aws_eks\n    min_nodes: \"${var.min_nodes}\"\n    max_nodes: \"${var.max_nodes}\"\n</code></pre>"},{"location":"features/variables/#override-at-runtime","title":"Override at runtime","text":"<p>Use repeatable <code>--var</code> flags or environment variables:</p> <pre><code>pltf terraform apply -f env.yaml -e prod --var min_nodes=3 --var max_nodes=6\n# or\nPLTF_VAR_min_nodes=3 PLTF_VAR_max_nodes=6 pltf generate -f env.yaml -e prod\n</code></pre>"},{"location":"features/variables/#environment-scoped-variables","title":"Environment-scoped variables","text":"<p>Service specs can declare per-environment variables under <code>envRef</code>:</p> <pre><code>envRef:\n  name: prod\n  path: ./env.yaml\n  variables:\n    containers: 5\nmodules:\n  - type: aws_k8s_service\n    min_containers: 1\n    max_containers: \"${var.containers}\"\n</code></pre>"},{"location":"features/variables/#parent-outputs","title":"Parent outputs","text":"<p>Services can use environment outputs via <code>${parent.&lt;output&gt;}</code>:</p> <pre><code>public_uri: \"${parent.domain}/hello\"\n</code></pre>"},{"location":"features/variables/#placeholder-catalog","title":"Placeholder catalog","text":"<ul> <li><code>${env_name}</code>, <code>${layer_name}</code> (intrinsics)</li> <li><code>${module.&lt;module_name&gt;.&lt;output_name&gt;}</code></li> <li><code>${parent.&lt;output_name&gt;}</code> (service only)</li> <li><code>${var.&lt;name&gt;}</code> (declared variables or CLI/env overrides)</li> </ul>"},{"location":"features/variables/#notes","title":"Notes","text":"<ul> <li>Required variables without defaults must be provided via <code>--var</code> or env.</li> <li>Precedence: env vars \u2192 service envRef vars \u2192 CLI <code>--var</code>.</li> <li>Values stay in Terraform variables (not locals) to avoid leaking secrets.</li> </ul>"},{"location":"getting-started/aws/","title":"Getting Started: AWS","text":"<p>This guide walks through provisioning a simple environment and service on AWS using pltf. You will create two YAML specs (environment and service), generate Terraform, and deploy.</p> <p> </p>"},{"location":"getting-started/aws/#1-prerequisites","title":"1) Prerequisites","text":"<ul> <li>Terraform v1.5+ (installed locally or via your CI)</li> <li>Docker (to build/push your images if needed)</li> <li>AWS credentials configured in your shell (e.g., <code>aws configure</code> or environment variables)</li> <li>(Optional) Custom modules directory if you want to bring your own modules</li> </ul> <p>Install pltf (Homebrew):</p> <pre><code>brew tap yindia/pltf\nbrew install pltf\n</code></pre> <p>Or use the install script:</p> <pre><code>/bin/bash -c \\\"$(curl -fsSL https://raw.githubusercontent.com/your-org/pltf/main/install.sh)\\\"\n</code></pre>"},{"location":"getting-started/aws/#2-create-an-environment-spec","title":"2) Create an Environment spec","text":"<p>Create <code>env.yaml</code>:</p> <pre><code>apiVersion: platform.io/v1\nkind: Environment\nmetadata:\n  name: example-aws\n  org: demo\n  provider: aws\n  labels:\n    team: platform\n    cost_center: shared\nenvironments:\n  prod:\n    account: \\\"123456789012\\\"\n    region: us-east-1\n    backend:\n      type: s3            # state backend (s3|gcs|azurerm)\n      profile: default    # optional cross-account profile\n    variables:\n      base_domain: prod.demo.internal\n      cluster_name: demo-eks\n    modules:\n      - type: aws_base\n      - type: aws_eks\n      - type: aws_k8s_base\n</code></pre> <p>What this does: - Configures AWS provider/region and S3 backend. - Creates networking, an EKS cluster, and base Kubernetes add-ons. - Exposes outputs (e.g., cluster endpoint/CA) for services.</p> <p>Generate and apply:</p> <pre><code>pltf terraform plan -f env.yaml -e prod\npltf terraform apply -f env.yaml -e prod\n</code></pre> <p>First apply can take ~15 minutes. You can inspect outputs:</p> <pre><code>pltf terraform output -f env.yaml -e prod --json\n</code></pre>"},{"location":"getting-started/aws/#3-create-a-service-spec","title":"3) Create a Service spec","text":"<p>Create <code>service.yaml</code>:</p> <pre><code>apiVersion: platform.io/v1\nkind: Service\nmetadata:\n  name: payments-api\n  org: demo\n  provider: aws\n  envRef:\n    name: prod\n    path: ./env.yaml\nspec:\n  variables:\n    image: ghcr.io/demo/payments:latest\n  modules:\n    - name: app\n      type: aws_k8s_service\n      port:\n        http: 8080\n      public_uri: \\\"/payments\\\"\n      links:\n        - app-bucket: [write]\n    - name: app-bucket\n      type: aws_s3\n      bucket_name: \\\"payments-${env_name}\\\"\n</code></pre> <p>What this does: - Deploys a Kubernetes service on the EKS cluster created above. - Provisions an S3 bucket and links it to the app with write permissions (IRSA policy is generated).</p> <p>Generate and apply:</p> <pre><code>pltf terraform plan -f service.yaml -e prod\npltf terraform apply -f service.yaml -e prod\n</code></pre>"},{"location":"getting-started/aws/#4-access-the-service","title":"4) Access the service","text":"<ul> <li>Find the load balancer host from outputs: <code>pltf terraform output -f service.yaml -e prod | grep load_balancer_raw_dns</code></li> <li>Curl the path: <code>curl http://&lt;lb&gt;/payments</code></li> </ul>"},{"location":"getting-started/aws/#5-cleanup","title":"5) Cleanup","text":"<pre><code>pltf terraform destroy -f service.yaml -e prod\npltf terraform destroy -f env.yaml -e prod\n</code></pre>"},{"location":"getting-started/aws/#6-next-steps","title":"6) Next Steps","text":"<ul> <li>Review AWS architecture and module docs in the References section.</li> <li>Add more modules (RDS, Redis, SES, SNS, SQS) and link them for IAM/IRSA wiring.</li> <li>Use profiles (<code>~/.pltf/profile.yaml</code>) to set default env/modules root and cross-account backends.</li> </ul>"},{"location":"getting-started/azure/","title":"Getting Started: Azure","text":"<p>Placeholder. Provide steps for Azure environment/service, backend (azurerm or s3/gcs), and custom modules.</p>"},{"location":"getting-started/gcp/","title":"Getting Started: GCP","text":"<p>Placeholder. Provide steps for GCP environment/service, backend (gcs or s3), and custom modules.</p>"},{"location":"references/aws/","title":"AWS Reference","text":"<p>The next generation of Infrastructure-as-Code: work with high-level constructs instead of getting lost in low-level cloud configuration. Status: active development; review generated code before applying.</p> <p>AWS is fully supported for environments, services, and modules. This page summarizes how the AWS provider, backends, and module wiring work in pltf.</p> <p> </p>"},{"location":"references/aws/#provider-and-backends","title":"Provider and Backends","text":"<ul> <li>Provider: Automatically injected; version comes from the central versions file. Region is taken from your env spec.</li> <li>Backends: You can store state in <code>s3</code>, <code>gcs</code>, or <code>azurerm</code> even when targeting AWS. For cross-account S3, set <code>backend.profile</code>. Optional <code>backend.region</code> overrides the bucket region.</li> <li>Default tags: Labels in your env/service specs become global tags on the AWS provider.</li> </ul>"},{"location":"references/aws/#example-environment-service","title":"Example (Environment + Service)","text":"<pre><code>apiVersion: platform.io/v1\nkind: Environment\nmetadata:\n  name: example-aws\n  org: pltf\n  provider: aws\n  labels:\n    team: platform\n    cost_center: shared\nenvironments:\n  prod:\n    account: \"556169302489\"\n    region: us-east-1\n    backend:\n      type: s3\n      profile: cross-account\n    modules:\n      - type: aws_base\n      - type: aws_eks\n      - type: aws_k8s_base\n</code></pre> <pre><code>apiVersion: platform.io/v1\nkind: Service\nmetadata:\n  name: payments-api\n  org: pltf\n  provider: aws\n  envRef:\n    name: prod\n    path: ../env.yaml\nspec:\n  variables:\n    image: ghcr.io/acme/payments:latest\n  modules:\n    - name: app\n      type: aws_k8s_service\n      port:\n        http: 8080\n      links:\n        - app-bucket: [write]\n        - app-queue: [consume]\n    - name: app-bucket\n      type: aws_s3\n      bucket_name: \"payments-${env_name}\"\n    - name: app-queue\n      type: aws_sqs\n</code></pre>"},{"location":"references/aws/#modules-and-fields","title":"Modules and Fields","text":"<ul> <li>Fields: Each module instance accepts inputs declared in its <code>module.yaml</code>. Only set what you need; defaults apply otherwise.</li> <li>Names: <code>name</code> is optional; defaults to the module <code>type</code>. Names are used for Terraform resource names and template placeholders.</li> <li>Types: <code>type</code> selects the module implementation. Embedded AWS modules are documented under \u201cModules (AWS)\u201d in the nav.</li> <li>Sources: Add <code>source: custom</code> to pull a module from your custom modules root; otherwise the embedded catalog is used.</li> </ul>"},{"location":"references/aws/#linking","title":"Linking","text":"<p>Linking lets a module consume outputs of another:</p> <pre><code>links:\n  - app-bucket: [read, write]\n  - app-queue: [consume]\n</code></pre> <p>When links are present, pltf automatically renders IAM policies and (for Kubernetes) IRSA trusts. Supported AWS link targets include S3, SQS, SNS, SES, DynamoDB, RDS, and more via module metadata.</p>"},{"location":"references/aws/#template-placeholders","title":"Template placeholders","text":"<ul> <li><code>${env_name}</code> and <code>${layer_name}</code> become the resolved environment/service names.</li> <li><code>${module.&lt;module_name&gt;.&lt;output_name&gt;}</code> references another module\u2019s output.</li> <li><code>${parent.&lt;output_name&gt;}</code> references outputs from the parent environment when authoring a service.</li> <li><code>${var.&lt;name&gt;}</code> references variables defined in the spec or via <code>--var</code>.</li> </ul>"},{"location":"references/aws/#useful-commands","title":"Useful commands","text":"<ul> <li><code>pltf module list -o table</code> \u2014 see available AWS modules.</li> <li><code>pltf module get aws_eks</code> \u2014 inspect inputs/outputs.</li> <li><code>pltf generate -f env.yaml -e prod</code> \u2014 render Terraform for AWS.</li> <li><code>pltf terraform plan/apply ...</code> \u2014 generate + execute Terraform (plan/apply/destroy/output/force-unlock).</li> </ul> <p>See the module-specific pages under \u201cModules (AWS)\u201d for detailed inputs, outputs, and examples.</p>"},{"location":"references/aws_eks_access/","title":"AWS EKS Access","text":"<p>How to access EKS clusters generated by pltf.</p> <p> </p>"},{"location":"references/aws_eks_access/#kubeconfig","title":"Kubeconfig","text":"<ol> <li>Fetch outputs:    <code>bash    pltf terraform output -f env.yaml -e &lt;env&gt; --json | jq '.aws_eks'</code>    Note <code>k8s_cluster_name</code>, <code>k8s_endpoint</code>, and <code>k8s_ca_data</code>.</li> <li>Update kubeconfig:    <code>bash    aws eks update-kubeconfig \\      --region &lt;region&gt; \\      --name &lt;cluster&gt; \\      --profile &lt;aws-profile-if-needed&gt;</code>    Use the same AWS profile that has access to the environment account (or backend profile if you share credentials).</li> </ol> <p>Generated Terraform already configures Kubernetes and Helm providers using these outputs when you run <code>pltf terraform plan/apply</code>.</p>"},{"location":"references/aws_eks_access/#aws-iam-to-kubernetes-rbac","title":"AWS IAM to Kubernetes RBAC","text":"<p>EKS uses the <code>aws-auth</code> ConfigMap in <code>kube-system</code> to map IAM users/roles to Kubernetes groups.</p> <p>Example <code>aws-auth</code> data:</p> <pre><code>apiVersion: v1\ndata:\n  mapRoles: |\n    - groups: ['system:bootstrappers', 'system:nodes']\n      rolearn: arn:aws:iam::ACCOUNT_ID:role/pltf-live-example-dev-eks-default-node-group\n      username: system:node:{{EC2PrivateDNSName}}\n    - groups: ['system:masters']\n      rolearn: arn:aws:iam::ACCOUNT_ID:role/demo-admin\n      username: pltf-managed\n  mapUsers: |\n    - groups: ['system:masters']\n      userarn: arn:aws:iam::ACCOUNT_ID:user/demo-admin\n      username: pltf-managed\n</code></pre> <p>Fields: - <code>rolearn</code>/<code>userarn</code>: IAM principal. - <code>username</code>: friendly alias. - <code>groups</code>: Kubernetes RBAC groups (use <code>system:masters</code> for admin).</p>"},{"location":"references/aws_eks_access/#granting-access-via-pltf","title":"Granting access via pltf","text":"<p>Use <code>admin_arns</code> on <code>aws_k8s_base</code> to inject IAM admins without editing Kubernetes directly:</p> <pre><code>modules:\n  - type: aws_k8s_base\n    admin_arns:\n      - \"arn:aws:iam::123456789012:user/platform-admin\"\n      - \"arn:aws:iam::123456789012:role/platform-admin\"\n</code></pre>"},{"location":"references/aws_eks_access/#viewing-rbac-bindings","title":"Viewing RBAC bindings","text":"<pre><code>kubectl get clusterrolebindings -o json | jq -r '.items[] | select(.subjects[0].kind==\\\"Group\\\") | .metadata.name'\nkubectl get rolebindings -A -o json | jq -r '.items[] | select(.subjects[0].kind==\\\"Group\\\") | .metadata.name'\n</code></pre> <p>Example cluster role binding:</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: my-cluster-role-binding\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: system:discovery\nsubjects:\n  - apiGroup: rbac.authorization.k8s.io\n    kind: Group\n    name: my-group\n</code></pre> <p>This grants members of <code>my-group</code> the permissions of <code>system:discovery</code> across all namespaces.</p>"},{"location":"references/aws_eks_access/#summary","title":"Summary","text":"<ul> <li>Use <code>aws eks update-kubeconfig</code> with cluster outputs to get access.</li> <li>Add IAM admins via <code>admin_arns</code> on <code>aws_k8s_base</code> (maps to <code>system:masters</code>).</li> <li>For custom RBAC, edit <code>aws-auth</code> or create your own role/cluster role bindings.</li> </ul>"},{"location":"references/aws_eks_upgrade/","title":"AWS EKS Upgrade","text":"<p>How to upgrade the version of your EKS cluster created by pltf.</p>"},{"location":"references/aws_eks_upgrade/#overview","title":"Overview","text":"<p>EKS does not auto-upgrade clusters. Upgrade one minor version at a time (e.g., 1.24 \u2192 1.25). Steps below use the AWS console; CLI works too.</p>"},{"location":"references/aws_eks_upgrade/#step-1-control-plane","title":"Step 1: Control Plane","text":"<ol> <li>Open the EKS cluster (correct region).</li> <li>Click Update now on the control plane.</li> <li>Select the next Kubernetes version and start the update.</li> </ol> <p>Important: During control plane upgrade (~20 min) avoid new deploys or kubectl changes. Running workloads keep serving traffic.</p>"},{"location":"references/aws_eks_upgrade/#step-2-node-groups","title":"Step 2: Node Groups","text":"<ol> <li>Go to Configuration \u2192 Compute.</li> <li>For each managed node group, click Update now.</li> <li>Use Rolling update strategy and start the upgrade.</li> </ol> <p>Important: Nodes are replaced. If ingress is not HA, expect brief downtime while pods reschedule. Upgrade node groups one at a time.</p>"},{"location":"references/aws_eks_upgrade/#step-3-pin-versions-in-specs","title":"Step 3: Pin versions in specs","text":"<p>After upgrading, pin the new versions so future applies stay consistent:</p> <pre><code>modules:\n  - type: aws_eks\n    k8s_version: \"1.25\"\n  - type: aws_nodegroup\n    name: default\n    k8s_version: \"1.25\"\n</code></pre> <p>Then:</p> <pre><code>pltf terraform plan -f env.yaml -e prod\npltf terraform apply -f env.yaml -e prod\n</code></pre>"},{"location":"references/aws_eks_upgrade/#breaking-changes","title":"Breaking Changes","text":"<ul> <li>Review Kubernetes API deprecations for your target version.</li> <li>Ensure add-ons (CNI, metrics, ingress) are compatible.</li> <li>For multi-hop upgrades (e.g., 1.22 \u2192 1.24), step through each minor version.</li> </ul>"},{"location":"references/aws_eks_upgrade/#references","title":"References","text":"<ul> <li>AWS: https://docs.aws.amazon.com/eks/latest/userguide/update-cluster.html</li> <li>Versions: https://docs.aws.amazon.com/eks/latest/userguide/kubernetes-versions.html</li> </ul>"},{"location":"references/azure/","title":"Azure Reference","text":""},{"location":"references/azure/#azure-reference_1","title":"Azure Reference","text":"<p>Placeholder. Document provider settings, backend options (azurerm/s3/gcs), and guidance for custom modules or future Azure modules.</p>"},{"location":"references/gcp/","title":"GCP Reference","text":"<p>Placeholder. Document provider settings, backend options (gcs or s3), and guidance for custom modules.</p>"},{"location":"references/modules/aws_base/","title":"aws_base","text":"<p>Provision networking (VPC), subnets across AZs, flow logs, NAT, and a default KMS key + log bucket for the environment.</p>"},{"location":"references/modules/aws_base/#what-it-does","title":"What it does","text":"<ul> <li>Creates a new VPC (or imports an existing one) with public/private subnets across three AZs.</li> <li>Adds internet/NAT gateways and route tables for public/private egress.</li> <li>Enables VPC flow logs to the log bucket and provisions a default KMS key.</li> <li>Creates a log bucket for access/flow logs used by other modules.</li> </ul>"},{"location":"references/modules/aws_base/#fields","title":"Fields","text":"Name Description Default Required private_ipv4_cidr_blocks Cidr blocks for private subnets. One for each desired AZ ['10.0.128.0/21', '10.0.136.0/21', '10.0.144.0/21'] False private_subnet_ids List of pre-existing private subnets to use instead of creating new subnets for pltf. Required when var.vpc_id is set. False public_ipv4_cidr_blocks Cidr blocks for public subnets. One for each desired AZ ['10.0.0.0/21', '10.0.8.0/21', '10.0.16.0/21'] False public_subnet_ids List of pre-existing public subnets to use instead of creating new subnets for pltf. Required when var.vpc_id is set. False total_ipv4_cidr_block Cidr block to reserve for whole vpc 10.0.0.0/16 False vpc_id The ID of an pre-existing VPC to use instead of creating a new VPC for pltf False vpc_log_retention 90 False"},{"location":"references/modules/aws_base/#bring-your-own-vpc","title":"Bring your own VPC","text":"<p>To use an existing VPC, set <code>vpc_id</code>, <code>public_subnet_ids</code>, and <code>private_subnet_ids</code>. Public subnets must route to an internet gateway and assign public IPs. Private subnets must route 0.0.0.0/0 to a NAT gateway with a public IP. Misconfigured routes may yield Terraform errors like \"No routes matching supplied arguments found in Route Table\". IPv6 imports are not validated; dual-stack may work but is not verified.</p>"},{"location":"references/modules/aws_base/#outputs","title":"Outputs","text":"Name Description kms_account_key_arn ARN of the default KMS key for environment resources kms_account_key_id ID of the default KMS key private_subnet_ids Private subnet IDs provisioned/imported public_nat_ips Elastic IPs of NAT gateways public_subnets_ids Public subnet IDs provisioned/imported s3_log_bucket_name Name of the environment log bucket vpc_id VPC ID provisioned/imported"},{"location":"references/modules/aws_dns/","title":"aws_dns","text":"<p>Creates a Route53 hosted zone and ACM certificate with DNS validation, wiring records for ingress/load balancers.</p>"},{"location":"references/modules/aws_dns/#what-it-does","title":"What it does","text":"<ul> <li>Creates Route53 hosted zone and ACM cert with DNS validation or import.</li> <li>Exposes NS records and cert ARN for downstream modules.</li> </ul>"},{"location":"references/modules/aws_dns/#fields","title":"Fields","text":"Name Description Default Required cert_chain_included False False delegated False False domain True external_cert_arn False force_update False False upload_cert False False"},{"location":"references/modules/aws_dns/#outputs","title":"Outputs","text":"Name Description cert_arn ACM certificate ARN (created/imported/external). domain Domain name of the hosted zone. name_servers Delegated name servers. zone_id Route53 hosted zone ID."},{"location":"references/modules/aws_documentdb/","title":"aws_documentdb","text":"<p>Provision a DocumentDB cluster with subnet groups, encryption, backups, and security groups in the base VPC.</p>"},{"location":"references/modules/aws_documentdb/#what-it-does","title":"What it does","text":"<ul> <li>Creates a DocumentDB cluster with configurable engine version and instance count.</li> <li>Uses subnet groups and security groups from the VPC; enables encryption.</li> <li>Supports deletion protection and exposes host/user/password outputs.</li> </ul>"},{"location":"references/modules/aws_documentdb/#fields","title":"Fields","text":"Name Description Default Required deletion_protection A value that indicates whether the DB cluster has deletion protection enabled. The database can't be deleted when deletion protection is enabled. False False engine_version 4.0.0 False instance_class db.r5.large False instance_count Number of Instances for aws_docdb_cluster_instance 1 False"},{"location":"references/modules/aws_documentdb/#outputs","title":"Outputs","text":"Name Description db_host Cluster endpoint. db_password Master password. db_user Master username."},{"location":"references/modules/aws_dynamodb/","title":"aws_dynamodb","text":"<p>Creates a DynamoDB table with encryption, throughput settings, TTL, and optional point-in-time recovery.</p>"},{"location":"references/modules/aws_dynamodb/#what-it-does","title":"What it does","text":"<ul> <li>Creates a DynamoDB table with server-side encryption and customizable billing mode.</li> <li>Supports provisioned throughput settings and TTL via attributes.</li> <li>Exposes table ARN/ID and KMS key details.</li> </ul>"},{"location":"references/modules/aws_dynamodb/#fields","title":"Fields","text":"Name Description Default Required attributes True billing_mode PROVISIONED False hash_key False range_key False read_capacity 20 False write_capacity 20 False"},{"location":"references/modules/aws_dynamodb/#outputs","title":"Outputs","text":"Name Description kms_arn KMS key ARN used for encryption. kms_id KMS key ID used for encryption. table_arn Table ARN. table_id Table name/ID."},{"location":"references/modules/aws_eks/","title":"aws_eks","text":"<p>Creates an EKS control plane in private subnets, configurable Kubernetes version, logging, and OIDC provider for IRSA.</p>"},{"location":"references/modules/aws_eks/#what-it-does","title":"What it does","text":"<ul> <li>Provisions the EKS control plane in private subnets with security groups.</li> <li>Creates an OIDC provider for IRSA and enables control-plane logging.</li> <li>Stands up a default managed nodegroup with scaling/min/max and optional spot.</li> </ul>"},{"location":"references/modules/aws_eks/#fields","title":"Fields","text":"Name Description Default Required ami_type AL2023_x86_64_STANDARD False cluster_name True control_plane_security_groups List of security groups to give control plane access to [] False eks_log_retention 7 False enable_metrics True k8s_version 1.21 False kms_account_key_arn True max_nodes 5 False min_nodes 3 False node_disk_size 20 False node_instance_type t3.medium False node_launch_template {} False private_subnet_ids True spot_instances False False vpc_id True"},{"location":"references/modules/aws_eks/#outputs","title":"Outputs","text":"Name Description k8s_ca_data Cluster CA data (base64). k8s_cluster_name EKS cluster name. k8s_endpoint EKS API endpoint. k8s_node_group_security_id Security group ID for nodes. k8s_openid_provider_arn OIDC provider ARN for IRSA. k8s_openid_provider_url OIDC provider URL. k8s_version Kubernetes version."},{"location":"references/modules/aws_iam_policy/","title":"aws_iam_policy","text":"<p>Defines IAM policies (inline or managed) to attach to roles/users created by other modules.</p>"},{"location":"references/modules/aws_iam_policy/#what-it-does","title":"What it does","text":"<ul> <li>Creates a standalone IAM policy from a JSON document for reuse.</li> </ul>"},{"location":"references/modules/aws_iam_policy/#fields","title":"Fields","text":"Name Description Default Required file Json file path containing the Policy False"},{"location":"references/modules/aws_iam_policy/#outputs","title":"Outputs","text":"Name Description policy_arn IAM policy ARN. policy_id IAM policy ID. policy_name IAM policy name."},{"location":"references/modules/aws_iam_role/","title":"aws_iam_role","text":"<p>Creates IAM roles with inline/managed policies and OIDC trust for Kubernetes service accounts (IRSA).</p>"},{"location":"references/modules/aws_iam_role/#what-it-does","title":"What it does","text":"<ul> <li>Creates an IAM role with inline policy and optional managed policies.</li> <li>Supports IRSA/OIDC trust for Kubernetes service accounts and trust for other IAM principals.</li> <li>Auto-generates least-privilege policies from <code>links</code> when used with supported modules.</li> </ul>"},{"location":"references/modules/aws_iam_role/#fields","title":"Fields","text":"Name Description Default Required allowed_iams [] False allowed_k8s_services [] False extra_iam_policies [] False iam_policy True kubernetes_trusts [] False links [] False"},{"location":"references/modules/aws_iam_role/#outputs","title":"Outputs","text":"Name Description role_arn IAM role ARN."},{"location":"references/modules/aws_iam_user/","title":"aws_iam_user","text":"<p>Creates IAM users with optional access keys and managed/inline policy attachments.</p>"},{"location":"references/modules/aws_iam_user/#what-it-does","title":"What it does","text":"<ul> <li>Creates an IAM user with inline/managed policies.</li> <li>Optionally auto-generates policies from <code>links</code> and returns access keys if created.</li> </ul>"},{"location":"references/modules/aws_iam_user/#fields","title":"Fields","text":"Name Description Default Required extra_iam_policies [] False iam_policy True links [] False"},{"location":"references/modules/aws_iam_user/#outputs","title":"Outputs","text":"Name Description user_arn IAM user ARN."},{"location":"references/modules/aws_mysql/","title":"aws_mysql","text":"<p>Provisions an Aurora MySQL cluster with subnet group, encryption, backups, and optional multi-AZ.</p>"},{"location":"references/modules/aws_mysql/#what-it-does","title":"What it does","text":"<ul> <li>Provisions an Aurora MySQL cluster in private subnets with encryption.</li> <li>Supports multi-AZ, backups, retention, and public accessibility toggle.</li> <li>Exposes writer/reader endpoints and security/subnet group metadata.</li> </ul>"},{"location":"references/modules/aws_mysql/#fields","title":"Fields","text":"Name Description Default Required backup_retention_days How many days to keep the backup retention True db_name app False engine_version 5.7.mysql_aurora.2.04.2 False instance_class db.t3.medium False multi_az False False safety False False"},{"location":"references/modules/aws_mysql/#outputs","title":"Outputs","text":"Name Description db_host db_name db_password db_user"},{"location":"references/modules/aws_nodegroup/","title":"aws_nodegroup","text":"<p>Managed node group for EKS with scaling limits, instance type, disk size, and optional spot instances.</p>"},{"location":"references/modules/aws_nodegroup/#what-it-does","title":"What it does","text":"<ul> <li>Adds an EKS managed node group with scaling limits and instance type/disk controls.</li> <li>Supports spot instances and custom labels/taints (via launch template inputs if set).</li> </ul>"},{"location":"references/modules/aws_nodegroup/#fields","title":"Fields","text":"Name Description Default Required ami_type AL2023_x86_64_STANDARD False autoscaling_tags {} False labels {} False max_nodes 15 False min_nodes 3 False node_disk_size 20 False node_instance_type t3.medium False spot_instances False False taints [] False use_gpu False False"},{"location":"references/modules/aws_nodegroup/#outputs","title":"Outputs","text":"Name Description"},{"location":"references/modules/aws_postgres/","title":"aws_postgres","text":"<p>Provisions an Aurora Postgres cluster with subnet group, encryption, backups, and optional multi-AZ.</p>"},{"location":"references/modules/aws_postgres/#what-it-does","title":"What it does","text":"<ul> <li>Provisions an Aurora Postgres cluster in private subnets with encryption.</li> <li>Supports multi-AZ, backups, retention, and public accessibility toggle.</li> <li>Exposes writer/reader endpoints and security/subnet group metadata.</li> </ul>"},{"location":"references/modules/aws_postgres/#fields","title":"Fields","text":"Name Description Default Required backup_retention_days How many days to keep the backup retention True create_global_database True database_name True engine_version 11.9 False existing_global_database_id True extra_security_groups_ids True instance_class db.t3.medium False multi_az False False restore_from_snapshot True safety False False"},{"location":"references/modules/aws_postgres/#outputs","title":"Outputs","text":"Name Description db_host db_name db_password db_user global_database_id"},{"location":"references/modules/aws_redis/","title":"aws_redis","text":"<p>Provisions ElastiCache Redis with subnet group, encryption in-transit/at-rest, and parameter options.</p>"},{"location":"references/modules/aws_redis/#what-it-does","title":"What it does","text":"<ul> <li>Deploys ElastiCache Redis cluster/subnet group with in-transit/at-rest encryption.</li> <li>Configurable engine version, node class, cluster size, and parameter family.</li> <li>Outputs cache endpoints and security group details.</li> </ul>"},{"location":"references/modules/aws_redis/#fields","title":"Fields","text":"Name Description Default Required node_type cache.m4.large False redis_version 6.x False snapshot_retention_limit Days for which the Snapshot should be retained. 0 False snapshot_window When should the Snapshot for redis cache be done. UTC Time. Snapshot Retention Limit should be set to more than 0. 04:00-05:00 False"},{"location":"references/modules/aws_redis/#outputs","title":"Outputs","text":"Name Description cache_auth_token cache_host Redis host."},{"location":"references/modules/aws_s3/","title":"aws_s3","text":"<p>Creates an S3 bucket with encryption, versioning, lifecycle/replication options, and optional bucket policies.</p>"},{"location":"references/modules/aws_s3/#what-it-does","title":"What it does","text":"<ul> <li>Creates an encrypted S3 bucket (AES-256) with block-public-access by default.</li> <li>Supports custom bucket policy, CORS rules, and optional same-region replication.</li> <li>Optionally uploads static files with content-type detection and creates an OAI for CloudFront reads when needed.</li> <li>Can emit access logs to the provided log bucket.</li> </ul>"},{"location":"references/modules/aws_s3/#fields","title":"Fields","text":"Name Description Default Required block_public True False bucket_name True bucket_policy False cors_rule CORS configuration for the bucket. False files False s3_log_bucket_name False same_region_replication False False"},{"location":"references/modules/aws_s3/#outputs","title":"Outputs","text":"Name Description bucket_arn Bucket ARN. bucket_id Bucket name/ID. cloudfront_read_path Origin access identity path (if created)."},{"location":"references/modules/aws_ses/","title":"aws_ses","text":"<p>Configures SES domain/identities with DNS verification records and optional inbound/notification settings.</p>"},{"location":"references/modules/aws_ses/#what-it-does","title":"What it does","text":"<ul> <li>Verifies a domain in SES and configures MAIL FROM.</li> <li>Creates IAM policy for sending and exposes DKIM tokens and identity ARN.</li> </ul>"},{"location":"references/modules/aws_ses/#fields","title":"Fields","text":"Name Description Default Required domain True mail_from_prefix mail False zone_id True"},{"location":"references/modules/aws_ses/#outputs","title":"Outputs","text":"Name Description identity_arn SES identity ARN. sender_policy_arn IAM policy ARN permitting SES send."},{"location":"references/modules/aws_sns/","title":"aws_sns","text":"<p>Creates an SNS topic with encryption, delivery policies, and optional subscriptions.</p>"},{"location":"references/modules/aws_sns/#what-it-does","title":"What it does","text":"<ul> <li>Creates an SNS topic (standard or FIFO) with a dedicated KMS CMK.</li> <li>Applies a default topic policy for account root and subscribes provided SQS endpoints.</li> <li>Supports content-based deduplication for FIFO topics and custom delivery policy.</li> </ul>"},{"location":"references/modules/aws_sns/#fields","title":"Fields","text":"Name Description Default Required content_based_deduplication Enable content-based deduplication for FIFO topics. False False fifo Create a FIFO topic (adds .fifo suffix). False False sqs_subscribers List of SQS queue ARNs to subscribe. [] False"},{"location":"references/modules/aws_sns/#outputs","title":"Outputs","text":"Name Description kms_arn KMS key ARN for the topic. topic_arn SNS topic ARN."},{"location":"references/modules/aws_sqs/","title":"aws_sqs","text":"<p>Creates an SQS queue with encryption, visibility timeout, redrive policy, and optional DLQ linkage.</p>"},{"location":"references/modules/aws_sqs/#what-it-does","title":"What it does","text":"<ul> <li>Creates an SQS queue (standard or FIFO) with a dedicated KMS CMK.</li> <li>Configures default queue policy allowing account root, SNS, and EventBridge producers.</li> <li>Supports content-based deduplication, delivery delays, retention, and long polling.</li> <li>Outputs KMS ARN for wiring IRSA/IAM consumers.</li> </ul>"},{"location":"references/modules/aws_sqs/#fields","title":"Fields","text":"Name Description Default Required content_based_deduplication Enable content-based deduplication for FIFO queues. False False delay_seconds 0 False fifo Create a FIFO queue (adds .fifo suffix). False False message_retention_seconds 345600 False receive_wait_time_seconds 0 False"},{"location":"references/modules/aws_sqs/#outputs","title":"Outputs","text":"Name Description kms_arn KMS key ARN for the queue. queue_arn SQS queue ARN. queue_id SQS queue URL. queue_name SQS queue name."},{"location":"security/aws/","title":"AWS Architecture","text":"<p>Architecture overview for AWS deployments of pltf.</p>"},{"location":"security/aws/#description","title":"Description","text":"<ul> <li>Single-region deployments with networking across three AZs by default (public + private subnets). Public subnets are used for public load balancers; EC2/Databases stay in private subnets (NAT for egress).</li> <li>EKS cluster spans private subnets with managed node groups. Cluster version is configurable (<code>aws_eks.k8s_version</code>) and patched by AWS. Public endpoint by default (VPN/private endpoints can be added later). Secrets are encrypted via KMS.</li> <li>Datastores: modules for Postgres (Aurora), Redis (ElastiCache), DocumentDB. Multi-AZ supported; 5-day backup retention for Postgres/DocumentDB. Credentials are generated and passed securely to services.</li> <li>S3: buckets are private by default, encrypted at rest (AES-256); can be made public via inputs.</li> <li>SQS: queues created with dedicated KMS keys for encryption at rest.</li> <li>SNS: topics created with dedicated KMS keys for encryption at rest.</li> <li>IAM: IAM role/user modules with <code>links</code> auto-generate least-privilege policies (S3, SQS, SNS, SES, etc.) and IRSA trusts for Kubernetes services.</li> <li>DNS/SSL: Route53 hosted zone and ACM certificates; validation via Route53; records created to point to the load balancer.</li> </ul>"},{"location":"security/aws/#security-overview","title":"Security Overview","text":"<ul> <li>End-to-end TLS when using ingress + service mesh (Linkerd optional) and delegated domains.</li> <li>Databases and EC2s in private subnets; only NAT egress.</li> <li>Databases (Postgres/Redis/DocumentDB) encrypted at rest with KMS; connections use SSL.</li> <li>S3 buckets encrypted at rest (AES-256); private by default.</li> <li>SQS/SNS encrypted at rest with per-resource KMS keys.</li> <li>Networking gated by security groups (EKS-managed + module-specific SGs) with minimal port exposure.</li> <li>EKS nodes created with scoped IAM policies; cluster storage (Secrets) encrypted via KMS.</li> <li>K8s service accounts mapped to IAM roles via OIDC (IRSA); no long-lived credentials.</li> <li>No long-lived IAM credentials are created by default; ECR images remain private.</li> <li>5-day backup retention for Postgres/DocumentDB.</li> <li>Public EKS endpoint by default for simplicity; private/VPN options can be layered later.</li> </ul>"},{"location":"security/azure/","title":"Azure Architecture","text":"<p>Placeholder. Cover identity (AAD/SP), backend hardening, and network segmentation.</p>"},{"location":"security/compliance/","title":"Compliance","text":"<p>SOC 2 and PCI considerations for infrastructure deployed by pltf.</p>"},{"location":"security/compliance/#overview","title":"Overview","text":"<p>pltf aims to make SOC 2 and PCI alignment the default for cloud resources it provisions. Compliance is broader than infrastructure; this covers only the cloud layer. Engage a compliance partner for full org-level readiness.</p>"},{"location":"security/compliance/#methodology","title":"Methodology","text":"<ul> <li>We scan representative environments with Fugue/Regula for SOC2/PCI controls before releases.</li> <li>Findings are fixed when possible; otherwise documented below. Backward-incompatible changes are avoided; new defaults apply to newly created resources.</li> </ul>"},{"location":"security/compliance/#aws","title":"AWS","text":"<p>AWS infrastructure can meet SOC2/PCI with the following settings: - S3 buckets: deny non-SSL traffic; enable <code>same_region_replication</code> for backups. - Postgres (Aurora): enable <code>multi_az</code>.</p> <p>Example:</p> <pre><code>modules:\n  - name: db\n    type: aws_postgres\n    multi_az: true\n  - name: s3\n    type: aws_s3\n    same_region_replication: true\n    bucket_policy:\n      Version: \"2012-10-17\"\n      Statement:\n        - Sid: denyInsecureTransport\n          Effect: Deny\n          Principal: \"*\"\n          Action: \"s3:*\"\n          Resource:\n            - \"arn:aws:s3:::${parent_name}-${layer_name}/*\"\n            - \"arn:aws:s3:::${parent_name}-${layer_name}\"\n          Condition:\n            Bool:\n              aws:SecureTransport: \"false\"\n</code></pre> <p>Notes auditors may raise: - Terraform lock DynamoDB table is unencrypted (no customer data, only hashes). - Terraform state bucket logging is not enabled by default (bootstrap ordering). You may manually add logging to the log bucket. - The log bucket does not log itself.</p>"},{"location":"security/compliance/#gcp","title":"GCP","text":"<p>Current gaps to full SOC2/PCI: - GKE nodegroup VMs cannot disable <code>block-project-ssh-keys</code> easily. - GKE node disks via KMS key encryption are still limited (beta in TF); will adopt when GA. - Defaults without uniform bucket-level access (GCS state bucket, GCR-backed bucket) to avoid tedious per-user grants; can be manually enabled if desired.</p>"},{"location":"security/compliance/#azure","title":"Azure","text":"<p>Azure can meet SOC2/PCI with an extra user step: - Enable flow logs for the agent pool security group.</p> <p>We continue to monitor provider capabilities and will tighten defaults as features mature.</p>"},{"location":"security/gcp/","title":"GCP Architecture","text":"<p>Placeholder. Discuss IAM, service accounts, backend security, and network controls.</p>"},{"location":"security/kubernetes/","title":"Kubernetes Architecture","text":"<p>Architecture overview for Kubernetes clusters deployed by pltf.</p>"},{"location":"security/kubernetes/#description","title":"Description","text":"<p>pltf divides the cluster into namespaces for third-party integrations and for your services. Third-party components are deployed via Helm charts (v3) into their own namespaces; your services are deployed into namespaces derived from the service/layer name.</p>"},{"location":"security/kubernetes/#third-party-integrations-common-set","title":"Third-party integrations (common set)","text":"<ul> <li>Linkerd (service mesh) \u2014 mTLS, traffic control, golden metrics; chosen for simplicity and security.</li> <li>Metrics Server \u2014 HPA metrics (built-in on GKE/Azure; installed on EKS).</li> <li>Cluster Autoscaler \u2014 scales nodes (built-in on GKE/Azure; installed on EKS).</li> <li>Ingress NGINX \u2014 ingress controller routing LB traffic into the cluster.</li> <li>External DNS \u2014 manages DNS records for LBs (not needed on GKE/Azure by default).</li> <li>Datadog (optional) \u2014 metrics/logs/APM via the Datadog K8s integration module.</li> </ul>"},{"location":"security/kubernetes/#services-pltf-modules","title":"Services (pltf modules)","text":"<p>Each service (<code>aws_k8s_service</code>/<code>gcp_k8s_service</code>) creates: - Namespace named from the service (layer) name. - Deployment + pods, Service, optional Ingress. - Horizontal Pod Autoscaler (CPU/memory driven). - Service Account wired to cloud IAM via IRSA/Workload Identity; least privilege via links. - ConfigMap/Secrets for app config and credentials (secrets encrypted at rest by the cloud). - Internal DNS of the form <code>&lt;module_name&gt;.&lt;layer_name&gt;</code> for service-to-service calls.</p>"},{"location":"security/kubernetes/#security-overview","title":"Security Overview","text":"<ul> <li>Linkerd mTLS secures cross-service traffic.</li> <li>Official/Bitnami Helm charts, version-locked; IAM roles scoped to least privilege.</li> <li>Service accounts per service; no extra cluster roles granted by default.</li> <li>IRSA/Workload Identity/OIDC for cloud access; no long-lived credentials in pods.</li> <li>Secrets stored in K8s are encrypted at rest; cloud KMS used by the control plane.</li> <li>plft does not modify <code>aws-auth</code> beyond optional <code>admin_arns</code> configuration.</li> <li>Helm v3 used for all chart deployments.</li> </ul>"}]}